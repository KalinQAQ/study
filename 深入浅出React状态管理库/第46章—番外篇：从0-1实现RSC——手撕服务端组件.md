在前面章节中我们介绍了 RSC（React Server Components），从本章开始我们会尝试实现 RSC。实际上 RSC 不仅仅包含了服务端组件的实现，也包括了客户端组件、编译、缓存、路由等等。因此可以说 RSC 实现非常复杂，所幸，Dan 在离开 React 前写了一篇文章 [RSC From Scratch. Part 1: Server Components](https://github.com/reactwg/server-components/discussions/5)，我们可以以这篇文章为起点，揭开 RSC 神秘的面纱。

# 前置知识

为了大家更好的理解后面 RSC 的实现，我们需要有一些前置知识。我们在 React 中都是编写 JSX 语法的代码，但是 React 是怎么处理这些 JSX 代码的呢？



> 点击查看 Demo：https://babeljs.io/repl#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&build=&builtIns=false&corejs=3.21&spec=false&loose=false&code_lz=DwCwLgtgNgfAUAAgaApgQwCbyU4YCWYUKMAsgJ4IBGUA9gObAD0BRJiyTI6WHwVtDOWw5gaAE4EAxsRg0GzCdNl8mAofGbhoMIA&debug=false&forceAllTransforms=false&modules=false&shippedProposals=false&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=env%2Creact%2Cstage-2&prettier=false&targets=&version=7.25.6&externalPlugins=&assumptions=%7B%7D

首先 JSX 会经过 babel 编译为 `jsx` 函数，比如这样一段代码：


```js
<html>
  <head>
    <title>My blog</title>
  </head>
  <body>
    <article>blog</article>
  </body>
</html>
```

经过 babel 编译之后就变成了：


```js
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
_jsxs("html", {
  children: [_jsx("head", {
    children: _jsx("title", {
      children: "My blog"
    })
  }), _jsx("body", {
    children: _jsx("article", {
      children: "blog"
    })
  })]
});
```

这些代码在经过 `jsx` 函数执行之后就变成了一个对象：


```js
{
  $$typeof: Symbol.for("react.element"),
  type: 'html',
  props: {
    children: [
      {
        $$typeof: Symbol.for("react.element"),
        type: 'head',
        props: {
          children: {
            $$typeof: Symbol.for("react.element"),
            type: 'title',
            props: { children: 'My blog' }
          }
        }
      },
      {
        $$typeof: Symbol.for("react.element"),
        type: 'body',
        props: {
          children: [
            {
              $$typeof: Symbol.for("react.element"),
              type: 'article',
              props: {
                children: post
              }
            },
          ]
        }
      }
    ]
  }
}
```

他有一个我们更熟知的名字 —— VDOM（virtual DOM），React 后续所有操作比如 DIFF 算法、构建 Fiber 树等等都是基于这个对象之上进行操作的。用一张图来表示一下这个过程：


<p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e9c6026bb174f8cb0fd20d93e58e174~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1639&h=326&s=33158&e=png&b=ffffff" alt="image.png" width="80%" /></p>



# 实现

## 搭建你的第一个博客服务器

假设你写了很多博客，现在想要把这些博客展示给用户，因此你需要开发一个博客服务器，当用户请求服务器地址时，返回包含博客内容的 HTML，类似这样：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60f9e7783d5f422d8b1a0738e8a7eaf9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1491&h=1139&s=56116&e=png&b=ffffff" alt="image.png" width="70%" /></p>


用 NodeJS 我们可能会编写这样一段代码：

> 点击查看 Demo：https://codesandbox.io/p/devbox/nostalgic-platform-kvog0r



```js
import { createServer } from 'http';
import { readFile } from 'fs/promises';
import escapeHtml from  'escape-html';

createServer(async (req, res) => {
  const author = "Jae Doe";
  const postContent = await readFile("./posts/hello-world.txt", "utf8");
  sendHTML(
    res,
    `<html>
      <head>
        <title>My blog</title>
      </head>
      <body>
        <nav>
          <a href="/">Home</a>
          <hr />
        </nav>
        <article>
          ${escapeHtml(postContent)}
        </article>
        <footer>
          <hr>
          <p><i>(c) ${escapeHtml(author)}, ${new Date().getFullYear()}</i></p>
        </footer>
      </body>
    </html>`
  );
}).listen(8080);

function sendHTML(res, html) {
  res.setHeader("Content-Type", "text/html");
  res.end(html);
}
```

这里我们用 NodeJS 搭建了一个简单的服务器，并且用 `escapeHtml` 对字符串中的特殊字符（例如 `<`, `>`, `&`, `"` 等）进行转义，从而避免了可能的 HTML 注入攻击。


## 发明 JSX

> 点击查看 Demo：https://codesandbox.io/p/devbox/recursing-kepler-yw7dlx?file=%2Fserver.js

试想一下上面的代码有什么问题？

我们上面都是直接操作字符串，这非常容易造成问题，比如不匹配的 HTML 标签：


```js
<div>
  <p>title</p>
</p>
```

我们日常编写 React 代码使用的是 JSX，借助 JSX 我们可以解决我们刚才提到的这个问题，上面代码使用 JSX 编写看起来会像这样：


```js
createServer(async (req, res) => {
  const author = "Jae Doe";
  const postContent = await readFile("./posts/hello-world.txt", "utf8");
  sendHTML(
    res,
    <html>
      <head>
        <title>My blog</title>
      </head>
      <body>
        <nav>
          <a href="/">Home</a>
          <hr />
        </nav>
        <article>
          {postContent}
        </article>
        <footer>
          <hr />
          <p><i>(c) {author}, {new Date().getFullYear()}</i></p>
        </footer>
      </body>
    </html>
  );
}).listen(8080);
```

我们开头提到 JSX 会被 babel 进行编译，最终变为对象，因为我们最终给用户返回的是 HTML，因此需要对这个对象进行进一步处理。


```js
function renderJSXToHTML(jsx) {
  if (typeof jsx === "string" || typeof jsx === "number") {
    return escapeHtml(jsx);
  } else if (jsx == null || typeof jsx === "boolean") {
    return "";
  } else if (Array.isArray(jsx)) {
    return jsx.map((child) => renderJSXToHTML(child)).join("");
  } else if (typeof jsx === "object") {
    if (jsx.$$typeof === Symbol.for("react.element")) {
      let html = "<" + jsx.type;
      for (const propName in jsx.props) {
        if (jsx.props.hasOwnProperty(propName) && propName !== "children") {
          html += " ";
          html += propName;
          html += "=";
          html += escapeHtml(jsx.props[propName]);
        }
      }
      html += ">";
      html += renderJSXToHTML(jsx.props.children);
      html += "</" + jsx.type + ">";
      return html;
    } else throw new Error("Cannot render an object.");
  } else throw new Error("Not implemented.");
}
```

这里我们分别判断了节点的类型（`string`、`number`、`boolean`、`array`、`object`），并分别进行处理。也就是说是一个递归的过程，将 jsx 对象经过处理得到的字符串进行拼接最终的到整个 HTML 字符串。

## 发明组件

> 点击查看 Demo：https://codesandbox.io/p/devbox/thirsty-frost-8oug3o?file=%2Fserver.js

我们知道，合理的拆分组件十分重要，这样能够提升代码的可复用性、提高可维护性等等优势。因此我们接下来需要发明组件，首先我们先将上面的 JSX 进行拆分：


```js
function BlogPostPage({ postContent, author }) {
  return (
    <html>
      <head>
        <title>My blog</title>
      </head>
      <body>
        <nav>
          <a href="/">Home</a>
          <hr />
        </nav>
        <article>
          {postContent}
        </article>
        <Footer author={author} />
      </body>
    </html>
  );
}

function Footer({ author }) {
  return (
    <footer>
      <hr />
      <p>
        <i>
          (c) {author} {new Date().getFullYear()}
        </i>
      </p>
    </footer>
  );
}

createServer(async (req, res) => {
  const author = "Jae Doe";
  const postContent = await readFile("./posts/hello-world.txt", "utf8");
  sendHTML(
    res,
    <BlogPostPage
      postContent={postContent}
      author={author}
    />
  );
}).listen(8080);
```

也就是说我们拆分为了 `BlogPostPage` 和 `Footer` 组件，并从本地读取文章作为参数传入 `<BlogPostPage />` 组件中。

为了让上面的代码可以正常工作，我们需要完善一下 `renderJSXToHTML`，因为当前的 `renderJSXToHTML` 并没有包含对组件（函数类型）的处理，首先我们来看一下如果是一个组件，经过 babel 编译之后是什么：


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be1a04f288b44b4bbbc9c4b41fdf9ef6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2371&h=397&s=96559&e=png&b=fefefe)

也就是说组件这个函数会作为 jsx 函数的调用参数传入，因此我们可以通过对象上的 type 属性是否是函数判断是否是一个组件，对应我们修改下 `renderJSXToHTML`：


```js
if (jsx.$$typeof === Symbol.for("react.element")) {
  if (typeof jsx.type === "string") {
    let html = "<" + jsx.type;
    // ...
    html += "</" + jsx.type + ">";
    return html;
  } else if (typeof jsx.type === "function") { // 代表是一个组件
    // 调用这个组件，并把 props 传进去
    const Component = jsx.type;
    const props = jsx.props;
    const returnedJsx = Component(props);
    return renderJSXToHTML(returnedJsx); 
  } else throw new Error("Not implemented.");
}
```

## 发明路由

当然我们现在没有区分路由，无论请求哪个路由都会返回同一个页面：


<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f5af6a586f54075b0de5bde5cc8a714~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1492&h=536&s=146536&e=gif&f=100&b=fbfafe" alt="20240831223247.gif" width="70%" /></p>

为了更好的用户体验，我们需要区分路由返回不同的页面，如果输入一个不存在的路由我们给用户返回一个 404，我们来继续改造一下上面的代码，实现这样的效果：


<p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cf07782722442feb68f96d034378d2f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=892&h=708&s=214191&e=gif&f=74&b=fdfcff" alt="20240831224403.gif" width="50%" /></p>

然后我们来编写一下代码。

<p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/510a2d4cb89247c0a12b6418d31e1f09~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1133&h=626&s=80013&e=png&b=fffefe" alt="image.png" width="70%" /></p>

首先实现 `BlogLayout`，这是每个页面的公共部分：


```js
function BlogLayout({ children }) {
  const author = "Jae Doe";
  return (
    <html>
      <head>
        <title>My blog</title>
      </head>
      <body>
        <nav>
          <a href="/">Home</a>
          <hr />
        </nav>
        <main>
          {children}
        </main>
        <Footer author={author} />
      </body>
    </html>
  );
}
```

然后实现一下 `BlogIndexPage`：


```js
function BlogIndexPage({ postSlugs, postContents }) {
  return (
    <section>
      <h1>Welcome to my blog</h1>
      <div>
        {postSlugs.map((postSlug, index) => (
          <section key={postSlug}>
            <h2>
              <a href={"/" + postSlug}>{postSlug}</a>
            </h2>
            <article>{postContents[index]}</article>
          </section>
        ))}
      </div>
    </section>
  );
}
```

最后我们需要改造一下服务器处理：


```js
createServer(async (req, res) => {
  try {
    const url = new URL(req.url, `http://${req.headers.host}`);
    const page = await matchRoute(url);
    sendHTML(res, <BlogLayout>{page}</BlogLayout>);
  } catch (err) {
    console.error(err);
    res.statusCode = err.statusCode ?? 500;
    res.end();
  }
}).listen(8080);

async function matchRoute(url) {
  // 这里会根据 URL 返回对应的页面，如果访问的是 "/" 就需要读取全部文章，如果子路由就直接拿对应的文章
  // 比如 "/hello-world"，就读取 hello-world.txt 文章
  if (url.pathname === "/") {
    const postFiles = await readdir("./posts");
    const postSlugs = postFiles.map((file) => file.slice(0, file.lastIndexOf(".")));
    const postContents = await Promise.all(
      postSlugs.map((postSlug) =>
        readFile("./posts/" + postSlug + ".txt", "utf8")
      )
    );
    return <BlogIndexPage postSlugs={postSlugs} postContents={postContents} />;
  } else {
    const postSlug = sanitizeFilename(url.pathname.slice(1));
    try {
      const postContent = await readFile("./posts/" + postSlug + ".txt", "utf8");
      return <BlogPostPage postSlug={postSlug} postContent={postContent} />;
    } catch (err) {
      throwNotFound(err);
    }
  }
}

function throwNotFound(cause) {
  const notFound = new Error("Not found.", { cause });
  notFound.statusCode = 404;
  throw notFound;
}
```

## 发明服务端组件

> 点击查看 Demo：https://codesandbox.io/p/devbox/relaxed-pare-gicsdi?file=%2Fserver.js

至此我们终于进入了 RSC 的核心，我们来回顾一下现在的整体流程：


<p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e963118f522f454ca52a435105b76058~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=512&h=1141&s=41035&e=png&b=ffffff" alt="image.png" width="30%" /></p>

现在我们在渲染之前需要读取博客文章，然后传入到组件中并进行渲染最终返回给用户。

是否可以把这两个步骤合为一个，也就是在组件中直接读取博客文章。答案就是服务端组件（RSC），在服务端组件前面可以增加 async 从而让组件变成异步的，同时在组件中使用 `await` 来等待数据返回结果，例如直接读取博客文件，这看起来很酷，也让组件的行为变得更符合直觉。

借助 RSC，我们可以抽出一个单独的 Post 组件，父组件 `BlogIndexPage` 只需要向其中传入标题即可：


```js
async function Post({ slug }) {
  let content;
  try {
    content = await readFile("./posts/" + slug + ".txt", "utf8");
  } catch (err) {
    throwNotFound(err);
  }
  return (
    <section>
      <h2>
        <a href={"/" + slug}>{slug}</a>
      </h2>
      <article>{content}</article>
    </section>
  )
}
```

对应的我们需要改造一下 `BlogIndexPage`，读取目录中包含哪些博客：


```js
async function BlogIndexPage() {
  const postFiles = await readdir("./posts");
  const postSlugs = postFiles.map((file) =>
    file.slice(0, file.lastIndexOf("."))
  );
  return (
    <section>
      <h1>Welcome to my blog</h1>
      <div>
        {postSlugs.map((slug) => (
          <Post key={slug} slug={slug} />
        ))}
      </div>
    </section>
  );
}
```

由于读取数据都交给了组件内部去处理，因此上层就可以变得十分清爽，我们只需要判断路由即可：


```js
function Router({ url }) {
  let page;
  if (url.pathname === "/") {
    page = <BlogIndexPage />;
  } else {
    const postSlug = sanitizeFilename(url.pathname.slice(1));
    page = <BlogPostPage postSlug={postSlug} />;
  }
  return <BlogLayout>{page}</BlogLayout>;
}
```

由于组件变成了异步的，我们知道，组件本身其实就是个函数，并且异步具有传染性，因此在 `renderJSXToHTML` 需要变成异步的，并且调用组件函数时需要加上 `await`：


```js
async function renderJSXToHTML(jsx)  {
  // ...
  const returnedJsx = await Component(props);
  // ...
}
```

## 跳转时保留状态

现在当我们跳转时会发现本地状态会丢失，例如当我们增加一个 input 框并输入一些内容时：

<p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f9306c0e7294a239ef6689dddc149e6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1060&h=788&s=265911&e=gif&f=132&b=fdfcff" alt="20240831233717.gif" width="50%" /></p>

可以看到在路由之间进行跳转时本地状态会丢失，因为前面我们是以 `<a href={"/" + postSlug}>{postSlug}</a>` 的方式进行的跳转。为了解决这个问题我们需要做三件事情：

1. 拦截路由跳转，这样我们就可以手动获取内容避免重新加载整个页面
2. 当后续请求内容时，在服务端能够提供 JSX 对象而不是整个 HTML
3. 客户端在不破坏 DOM 的同时实现更新

### 拦截路由跳转，这样我们就可以手动获取内容避免重新加载整个页面

> 点击查看 Demo：https://codesandbox.io/p/devbox/agitated-bush-ql7kid

有没有发现，至此为止我们其实没有在客户端执行任何脚本，也就是说没有 script 标签。为了能够实现拦截路由跳转，我们需要给返回的 HTML 额外增加一个 `<script>` 标签引入 `client.js` 脚本：


```js
async function sendHTML(res, jsx) {
  let html = await renderJSXToHTML(jsx);
  html += `<script type="module" src="/client.js"></script>`;
  res.setHeader("Content-Type", "text/html");
  res.end(html);
}
```

当请求 `client.js` 脚本时我们将它读取出来并返回给前端：

```js
createServer(async (req, res) => {
  try {
    const url = new URL(req.url, `http://${req.headers.host}`);
    if (url.pathname === "/client.js") {
      await sendScript(res, "./client.js");
    } else if (url.searchParams.has("jsx")) {
      url.searchParams.delete("jsx");
      await sendJSX(res, <Router url={url} />);
    } else {
      await sendHTML(res, <Router url={url} />);
    }
  } catch (err) {
    console.error(err);
    res.statusCode = err.statusCode ?? 500;
    res.end();
  }
}).listen(8080);

async function sendScript(res, filename) {
  const content = await readFile(filename, "utf8");
  res.setHeader("Content-Type", "text/javascript");
  res.end(content);
}
```

现在我们可以编写 `client.js` 脚本来拦截路由跳转：



```js
let currentPathname = window.location.pathname;

async function navigate(pathname) {
  currentPathname = pathname;
  // 路由跳转时请求对应的 HTML
  const response = await fetch(pathname);
  const html = await response.text();

  if (pathname === currentPathname) {
    const bodyStartIndex = html.indexOf("<body>") + "<body>".length;
    const bodyEndIndex = html.lastIndexOf("</body>");
    const bodyHTML = html.slice(bodyStartIndex, bodyEndIndex);

    // 替换 HTML
    document.body.innerHTML = bodyHTML;
  }
}

window.addEventListener("click", (e) => {
  if (e.target.tagName !== "A") {
    return;
  }
  if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) {
    return;
  }
  const href = e.target.getAttribute("href");
  if (!href.startsWith("/")) {
    return;
  }
  e.preventDefault();
  window.history.pushState(null, null, href);
  navigate(href);
}, true);

window.addEventListener("popstate", () => {
  navigate(window.location.pathname);
});
```

至此我们完成了第一步，拦截了路由跳转，并实现了自定义函数 `navigate`，在 `navigate` 函数中我们请求了 HTML，并手动插入到页面中。

但现在并没有解决状态丢失的问题，因为整个 DOM 还是被更新了。


### 当后续请求内容时，在服务端能够提供 JSX 对象而不是整个 HTML

> 点击查看 Demo：https://codesandbox.io/p/devbox/competent-dawn-grmx8d?file=%2Fserver.js%3A1%2C1

回忆一下刚才我们实现 HTML 过程，我们会根据 JSX 对象来生成 HTML，那如果我们直接把 JSX 对象返回给前端，前端再根据差别动态更新 DOM 不就可以了，这样就可以解决上面 `<input>` 内容丢失的问题了。

为了能够让服务端区分客户端需要的是 HTML 还是 JSX 对象，我们可以在 URL 后面增加一个 query 来标记，当请求 URL 包含了 `?jsx` 时我们给用户返回 JSX 对象而不是整个 HTML。


```js
createServer(async (req, res) => {
  try {
    const url = new URL(req.url, `http://${req.headers.host}`);
    if (url.pathname === "/client.js") {
      // ...
    } else if (url.searchParams.has("jsx")) {
      url.searchParams.delete("jsx"); // Keep the url passed to the <Router> clean
      await sendJSX(res, <Router url={url} />);
    } else {
      await sendHTML(res, <Router url={url} />);
    }
    // ...
```

因为 JSX 是一个对象，从服务器传递给客户端我们需要将其进行序列化，这里我们使用 `JSON.stringify` 将其序列化为字符串：


```js
async function sendJSX(res, jsx) {
  const jsxString = JSON.stringify(jsx, null, 2);
  res.setHeader("Content-Type", "application/json");
  res.end(jsxString);
}
```

对应的我们也需要修改一下前端的 `navigate` 函数，当路由跳转时请求服务端的时候携带 `?jsx`。


```js
async function navigate(pathname) {
  currentPathname = pathname;
  const response = await fetch(pathname + "?jsx");
  const jsonString = await response.text();
  if (pathname === currentPathname) {
    alert(jsonString);
  }
}
```

现在服务端已经可以正确将 JSX 传输回来了：


<p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea45598e40af47548adf0c1197fcf2fb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1721&h=1516&s=293871&e=png&b=ffffff" alt="image.png" width="70%" /></p>



### 客户端在不破坏 DOM 的同时实现更新

目前在前端并没有执行水合（Hydration），也就是说前端不能交互，因此我们需要使用 `hydrateRoot`

```js
hydrateRoot(document, <App />);
```

但问题是现在在客户端没有像 `<App />` 这样的根组件，一种常见的方式是将 JSX 放到 `<script>` 随着 HTML 一起返回给前端：

```js
async function sendHTML(res, jsx) {
  let html = await renderJSXToHTML(jsx);

  // Serialize the JSX payload after the HTML to avoid blocking paint:
  const clientJSX = await renderJSXToClientJSX(jsx);
  const clientJSXString = JSON.stringify(clientJSX, stringifyJSX);
  html += `<script>window.__INITIAL_CLIENT_JSX_STRING__ = `;
  html += JSON.stringify(clientJSXString).replace(/</g, "\\u003c");
  html += `</script>`;
  // ...
```

前端从 `window` 上取出，然后进行水合：

```js
import { hydrateRoot } from 'react-dom/client';

const root = hydrateRoot(document, getInitialClientJSX());

function getInitialClientJSX() {
  const clientJSX = JSON.parse(window.__INITIAL_CLIENT_JSX_STRING__, reviveJSX);
  return clientJSX;
}
```

然后当路由跳转时利用 `root.render` 来 re-render：

```js
async function navigate(pathname) {
  currentPathname = pathname;
  const clientJSX = await fetchClientJSX(pathname);
  if (pathname === currentPathname) {
    root.render(clientJSX);
  }
}

async function fetchClientJSX(pathname) {
  const response = await fetch(pathname + "?jsx");
  const clientJSXString = await response.text();
  const clientJSX = JSON.parse(clientJSXString);
  return clientJSX;
}
```




## 代码重构

现在我们的代码已经可以正常工作了，但是为了更接近真实 RSC 的架构，让我们来对代码进行一些重构。

### 消除重复代码

上面代码中我们调用了 `renderJSXToHTML` 生成了 HTML，调用了 `renderJSXToClientJSX` 生成了 JSX 对象：

```js
async function sendHTML(res, jsx) {
  let html = await renderJSXToHTML(jsx);

  const clientJSX = await renderJSXToClientJSX(jsx);
```

这看起来有些重复，每个组件被调用了两次


```js
async function sendHTML(res, jsx) {
  const clientJSX = await renderJSXToClientJSX(jsx);

  let html = await renderJSXToHTML(clientJSX);
  // ...
```



### 使用 React renderToString 去渲染 HTML

> 点击查看 Demo：https://codesandbox.io/p/devbox/agitated-swartz-4hs4v1?file=%2Fserver%2Fssr.js

在一开始我们使用了自定义的 `renderJSXToHTML` 函数，这样当遇到服务端组件时可以 `await` 等待其渲染，但是由于我们将这部分逻辑拆成了 `renderJSXToClientJSX`，因此可以把它删掉使用 React 内置的 `renderToString` 来进行渲染：


```js
import { renderToString } from 'react-dom/server';

// ...

async function sendHTML(res, jsx) {
  const clientJSX = await renderJSXToClientJSX(jsx);
  let html = renderToString(clientJSX);
  // ...
```


### 拆分服务

现在当我们生成 HTML 时需要经过两步：

- `renderJSXToClientJSX` 调用组件生成客户端 JSX
- `renderToString` 将 JSX 转换成 HTML

这两个过程是独立的，因此我们不必在同一个进程甚至在同一个服务器中执行，因此我们来将原先的 `server.js` 拆分为两个文件：

- `server/rsc.js`:
- `server/ssr.js`: 该服务

对应的我们修改一下 `package.json`:


```js
  "scripts": {
    "start": "concurrently \"npm run start:ssr\" \"npm run start:rsc\"",
    "start:rsc": "nodemon -- --experimental-loader ./node-jsx-loader.js ./server/rsc.js",
    "start:ssr": "nodemon -- --experimental-loader ./node-jsx-loader.js ./server/ssr.js"
  },
```


# 总结


我们来回顾一下

1. 首先我们想把我们写的博客展示给用户看，因此我们写了一段简单的 NodeJS 脚本，读取本地博客.txt文件，并拼接成 HTML 字符串返回给用户。
2. 因为直接操作字符串非常容易出错，因此我们发明了 JSX 来解决这个问题。
3. 为了提升代码的可复用性、可维护性我们发明了组件。
4. 为了能够在不同的 URL 对应不同的博客，我们发明了路由。
5. 接下来我们发明了服务端组件（RSC），这些组件可以是异步的，并且我们在服务端组件直接读取了博客内容。
6. 为了在路由跳转时可以保持状态，同时提高性能

用两张图来表示用户请求的处理流程，这里会分为两种情况：

- 一种时用户首次请求过来，此时返回的是 HTML：

<p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4edd3b87b192413f9ec43e8561308f44~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1086&h=969&s=154123&e=png&b=ffffff" alt="image.png" width="70%" /></p>

- 另一种上发生在路由跳转时，此时返回的是 JSX 对象：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c90d71d176984de0a03800508079d41e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1171&h=1016&s=219235&e=png&b=ffffff" alt="image.png" width="70%" /></p>



本篇参考了 Dan 的 [RSC From Scratch. Part 1: Server Components](https://github.com/reactwg/server-components/discussions/5) 这篇文章，大家也可以去看看纯英文版本，无疑这篇文章帮助我们深入了解了 RSC 是如何工作的。在下一篇中我们会基于此之上继续完善，实现客户端组件。
 