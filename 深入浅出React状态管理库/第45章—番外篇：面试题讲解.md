本篇我们来分享一些状态管理库相关的面试题，题目和答案都是原创的，相信无论你作为`面试官`/`应聘者`了解这些问题都会非常有帮助。

 

更多问题欢迎 👏 在评论区交流。

### 1. 谈谈你对状态的理解？

 

在 React 中我们可以用一个公式来描述状态和 UI 的关系，即：


```js
UI = f(状态）
```

React 的一个核心概念是幂等性，也就是说在 React Component 中，相同的输入（`props`、`state`、`context`）总会得到相同的输出，那我们可以用一个公式来表达：


```js
UI = f(props, state, context）
```

因此在 React 中状态其实本质上只有三种：`props`、`state`、`context`，即使我们日常使用的各种状态管理库背后也是使用这些。

而根据使用范围和管理方式，状态又可以大致划分为三类。

- **局部状态**：这是指那些`仅在单个组件内使用和维护`的状态。在函数式组件中，我们通常使用 `useState` 或 `useReducer` 钩子来创建和管理这些状态。在类式组件中，则使用 `this.state` 和 `this.setState` 方法。局部状态一般用于控制组件的内部行为，如用户输入、表单控制等。

-  **全局状态**：当状态`需要在多个组件间共享`时，我们使用全局状态。这些状态不属于某一个特定的组件，而是整个应用的共享资源。为了管理全局状态，React 提供了 Context API，但通常我们会选择更专业的库，如 React Redux、Zustand、Jotai 等，它们提供了更强大的功能和更好的开发体验。

-  **服务器状态**：这种状态`涉及到与服务器的交互`。服务器状态是从服务器获取的数据，并在前端应用中展示和管理。例如，当你从 API 获取数据并在 UI 中展示时，就在处理服务器状态。管理服务器状态的流行库包括 Tanstack Query、SWR、Apollo 等，它们提供数据获取、缓存、更新等功能，简化了与后端数据交互的复杂性。




### 2. 用过哪些状态管理库？状态管理库帮助我们解决了什么问题？

- 状态共享：状态管理库帮助我们在多个组件间共享状态。
- 状态同步：当 Store 状态改变时需要通知各个组件 re-render，从而保持各个组件间状态的同步。
- 保证性能：状态管理库提供各种方式来精确控制组件的渲染逻辑，避免组件无关的状态更新造成 re-render，从而保证应用的性能。
- 开发工具：一个好的状态管理库需要有 DevTools 的支持，包含查看状态以及时间旅行等功能，帮助我们提高开发效率。
- 其它：比如 TanStack Query 给我们提供的预加载、错误重试、乐观更新、请求去重、查询取消等等能力。


### 3. 平时是怎么做技术选型的？在选择状态管理库时会考虑哪些因素？

-   **受欢迎/流行程度**：一个更流行的库意味着它经过更多项目的验证，因此更为可靠。
-   **活跃程度**：一个活跃的库表示它正在持续更新和维护，能够及时修复 bug 并及时支持 React 新特性，迎合 React 发展。
-   **完善的使用文档**：一个清晰完善的文档非常重要，一个好的文档无论新手还是具有经验的开发者都能从中找到日常开发中所需的信息和解决方案。
-   **上手难度**：一个容易上手的状态管理库可以减少开发者学习成本，新同学加入后也能够快速上手进行开发，从而加速项目开发流程。
-   **包体积**：如果一个库的体积较大，则会对应用的性能造成影响，增加应用的加载时间，同时也会增大带宽成本。
-   **原子化/非原子化**：`原子化`是指整个应用的外部状态被拆分为了一个个分片的状态片段，每个状态片段保存在各自的 atom 中，各自的 atom 组合交错共同组成了整个应用的状态。相对比较灵活，无数 atom 在大型项目中不方便管理和维护。
-   **Mutable/Immutable**：Mutable 和 Immutable 各有优劣。Mutable 可以让我们在编写代码时更加的自然、清晰和符合直觉，而 Immutable 做不到这一点。Immutable 可以保证可预测性，而 Mutable 则难以保证这一点。
-   **优化方式**：根据优化方式可以大致分为自动优化和手动优化，手动优化意味着需要更高的开发者素质。
-   **DevTools支持**：一个好的 DevTools 支持非常重要，良好的 DevTools 支持可以显著提高开发效率。
-   **React新特性的支持程度**：随着React不断更新和引入新特性，需要确保状态管理库与这些新特性是否兼容。
-   **兼容性**：需要确保库与你的技术栈的兼容性，包括 React版本、Proxy 浏览器兼容版本、SSR 兼容性等。




### 4. 什么是 prop drilling（prop 下钻）问题，它会带来哪些问题？

> 参考 [React Context 性能挑战及其优化之道](https://juejin.cn/book/7311970169411567626/section/7313462656471334949) 一节

prop drilling 指数据在多个组件层级中进行传递，即数据会从顶层组件传递到深层子组件，例如：


```js
function ComponentA() {
  const count = 10;
  return <ComponentB count={count} />
}

function ComponentB({ count }) {
  return <ComponentC count={count} />
}

function ComponentC({ count }) {
  return <ComponentD count={count} />
}

function ComponentD({ count }) {
  return <ComponentE count={count} />
}

function ComponentE({ count }) {
  return <div>{count}</div>
}
```

<p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/661dd9b1b90848dfae3601eba868489a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=970&h=1146&s=76226&e=png&b=ffffff" alt="image.png" width="50%" /></p>

在上面的例子中，`count` 属性从 ComponentA -> ComponentB -> ComponentC -> ComponentD -> ComponentE 中逐层传递。这就是典型的 **prop drilling（prop 下钻）。**

prop drilling 会很容易引发以下几个问题。

-   **产生性能问题**。当你在多个组件间传递同一个属性时，这个属性变化会导致所有组件发生 re-render，即使某些组件没有真正使用到该值，这会导致不必要的开销，从而造成`性能问题`。

-   **减少可维护性**。prop drilling 会导致你的代码可读性变差，应用变得难以维护，尤其是应用变得足够复杂时，你会发现很难增加新的功能或者改变现有的逻辑，并且容易滋生 Bug，定位和解决 Bug 也变得更加困难。
-   **增加心智负担**。当跨多个组件传递同一个值时，你需要在每一个组件中添加额外的 props，即使这些组件并没有直接使用到。你会发现需要花费更多精力来追踪这个值的去向，以及这个值在哪个组件中真正被使用到，这无疑会在开发和维护中带来更多的心智负担。


### 5. React Context 内部存在什么问题，如何解决？

> 参考 [React Context 性能挑战及其优化之道](https://juejin.cn/book/7311970169411567626/section/7313462656471334949) 一节

React Context 会引发额外 re-render 的问题，[比如](https://codesandbox.io/s/issue-kq83xc?file=/src/App.js)：

```js
const context = createContext(null);

const Count1 = () => {
  const { count1, setCount1 } = useContext(context);
  console.log("Count1 render");
  return <div onClick={() => setCount1(count1 + 1)}>count1: {count1}</div>;
};

const Count2 = () => {
  const { count2 } = useContext(context);
  console.log("Count2 render");
  return <div>count2: {count2}</div>;
};

const StateProvider = ({ children }) => {
  const [count1, setCount1] = useState(0);
  const [count2, setCount2] = useState(0);
  return (
    <context.Provider
      value={{
        count1,
        count2,
        setCount1,
        setCount2
      }}
    >
      {children}
    </context.Provider>
  );
};

const App = () => (
  <StateProvider>
    <Count1 />
    <Count2 />
  </StateProvider>
);
```

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3e50b215602443e9228cd05e366f584~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=920&h=984&s=41962&e=gif&f=24&b=fdfcff" width="50%" alt=""  /></p>

比如在这个例子中当我们点击按钮时候会更新 `count1` 的状态，但 `Count2` 组件也被重新渲染了，这就是使用 React Context 带来的性能问题。

这个问题有很多优化方案：

1. 拆分 context：将 context 进行拆分，将 “大” context 拆分为多个 “小” context，这样每个组件只关心自己所用到的 context。
2. 借助 `memo`：将组件进行拆分，拆分出的子组件用 `memo` 包裹。
3. 借助 `useMemo`：在组件的 `return` 中，用 `React.useMemo` 包裹，将 Context 中消费的值，作为其依赖项。
4. 借助直接对 React Context 来优化的状态管理库，比如 use-context-selector。
5. 借助不直接基于 Context 的状态管理库，比如 Jotai、Zustand、Redux 等等都是。


### 6. 有没有了解过内部的实现机制？状态管理库是如何保证组件间状态的一致性的？

状态管理库有三种方式可以来触发组件 re-render 从而保证组件间从 Store 拿到的状态是统一的：

- 使用 `useState`：


```js
const [state, setState] = useState(initialState)
```

- 使用 `useReducer`：


```js
const [state, dispatch] = useReducer(reducer, initialArg)
```

- 使用 `useSyncExternalStore`（或者 `useSyncExternalStoreWithSelector`，背后其实也是使用 `useSyncExternalStore`）：


```js
const snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot)
```

对于上面的例子中：

- `useState` 返回了 `setState`，调用 `setState` 可以更新状态并使组件 re-render。
- `useReducer` 返回了 `dispatch`，调用 `dispatch` 可以更新状态并使组件 re-render。
- `useSyncExternalStore` 需要你传入 `subscribe`，`useSyncExternalStore` 会传入一个函数，这个调用这个函数可以使组件 re-render。

状态管理库的实现形式会把这些更新状态的函数保存起来，通常是一个 `Set` 数据结构，这样当更新 Store 时，会遍历整个 `Set` 中的函数来触发各个组件 re-render，用图来表示：



![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9f619c7718148ed8d66ae304e80c243~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2088&h=1070&s=111014&e=png&b=ffffff)



但随着 React18 的到来通常来说状态管理库都会使用 `useSyncExternalStore`/`useSyncExternalStoreWithSelector` 来避免并发更新带来的 Tearing 问题。

### 7. 状态管理库是怎么帮助我们提升应用的性能，避免无用 re-render 的。

根据这个问题可以大致对状态管理库分为三类：

- 以 Zustand、React Redux 为首的基于 selector 优化的状态管理库，背后会使用  [use-sync-external-store](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fuse-sync-external-store) 库，需要我们传入 selector 选出组件关心的状态，对于不关心的状态变更不会触发组件 re-render。


- 以 Jotai 为首的基于原子化模型的状态管理库：每个原子维护自己的小的状态片段，并通过原子之间的相互依赖关系阻止应用 re-render，提高性能。这类状态管理库不需要我们传入 selector。


- 以 Valtio、Mobx 为首的基于 Mutable 的状态管理库：这类状态管理库内部采用 Proxy 来实现，会自动监听组件使用了哪些状态，只有这些状态变化才会触发组件 re-render。




### 8. 怎么理解 Mutable（可变） 与 Immutable（不变）？

> 参考 [Immer：JavaScript 不可变数据的革命性管理](https://juejin.cn/book/7311970169411567626/section/7331920132526047259) 一节

在讨论状态管理库时，我们可以从多个角度对其进行分类。其中的一种分类方法就是根据状态的可变性分为 `Mutable（可变）`与`Immutable（不可变）`。

- **Mutable（可变）** ：指的是创建对象之后任何状态更新都是基于对原先对象的基础之上进行的，典型的比如 MobX、Valtio 都是属于此类。比如：


```js
// Valtio
<button onClick={() => (state.deep.nested.obj.count += 1)}>+1</button>
```

- **Immutable（不可变）** ：指的是对象一旦创建就不能被修改，需要基于这个对象生成新的对象而保证原始对象不变，比如 Zustand、Jotai、Redux 都属于这一类。比如：


```js
// Zustand
increment: () =>
  set((state) => ({
    deep: {
      ...state.deep,
      nested: {
        ...state.deep.nested,
        obj: {
          ...state.deep.nested.obj,
          count: state.deep.nested.obj.count + 1,
        },
      },
    },
  })),
```

对于复杂的多层嵌套的数据结构来说，Immutable 方式处理起来非常麻烦，并且容易出错，而 Mutable 方式则更加的自然、清晰和符合直觉。除此之外，基于 Mutable 方案下的状态管理库内部基于 Proxy 来实现，会监听组件对于状态的使用情况，从而在更新状态时正确触发对应的组件完成 re-render，因此这种方案下我们可以认为性能默认就是最优的，不需要手动来优化。

但是 Immutable 可以保证可预测性，而 Mutable 则难以保证这一点。可预测性指的是当状态发生变化时，这些变化是可以被追踪以及最终状态的更新结果是明确的。而 Mutable 方式则会直接修改原始的数组，当应用中不同的地方以不可预期的方式修改了这个状态，尤其是在复杂的应用中，最终这个状态可能会难以追踪，在遇到 Bug 时也难以排查。


### 9. 用过 Immer 吗？Immer 帮助我们解决了什么问题？

> 参考 [Immer：JavaScript 不可变数据的革命性管理](https://juejin.cn/book/7311970169411567626/section/7331920132526047259) 一节

Mutable 可以让我们在编写代码时更加的自然、清晰和符合直觉，而 Immutable 做不到这一点。

Immutable 可以保证可预测性，而 Mutable 则难以保证这一点。

MobX 作者写了一个叫 Immer 的库，Immer 独特地结合了两者的优点，允许我们可以以 Mutable 的风格来编写状态更新逻辑，同时保留 Immutable 的所有优势。

<p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2313aade4974dde98833c2e862dff0d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1886&h=728&s=89669&e=png&b=f8f8f8" alt="image.png" width="70%" /></p>

在背后 Immer 会基于当前状态为我们生成一个副本（Draft），所有的操作在这个副本上进行，而不会改动到原先的状态，当完成了状态的更改后，Immer 会根据副本的修改为我们计算生成最终的状态。


### 10. 什么是 React Race Condition（竞态）？在项目中是怎么解决这个问题的？

> 参考：[浅析 Race Condition（竞态）及其解决策略](https://juejin.cn/book/7311970169411567626/section/7318564163163258918#heading-0)一节

React Race Condition 是指组件的状态在更新过程中，因为异步操作的结果顺序不确定性，导致最终的组件状态不符合预期的问题。[例如](https://codesandbox.io/p/sandbox/race-condition1-qsxnfj?file=%2Fsrc%2FApp.js%3A33%2C2)：

<p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f49088f0ec74072af2f5beef59dad38~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=388&h=164&s=71847&e=gif&f=76&b=fcfbfe" alt="20240420184612_rec_.gif" width="30%" /></p>

```js
import { useEffect, useState } from "react";

function Display({ id }) {
  const [title, setData] = useState("");
  useEffect(() => {
    const fetchData = async () => {
      const res = await fetch(
        `https://jsonplaceholder.typicode.com/todos/${id}?_delay=${5000 / id}`
      );
      const { title } = await res.json();
      setData(`${id}-${title}`);
    };
    fetchData();
  }, [id]);
  return <div>{title || "loading"}</div>;
}

export default function App() {
  const [id, setId] = useState(1);
  return (
    <>
      <button
        onClick={() => {
          setId((id) => id + 1);
        }}
      >
        +1
      </button>
      <Display id={id} />
    </>
  );
}
```

在这个例子中可以看到，当我们连续点击两次按钮时预期应该展示 `id` 为 3 所对应的 todo，而由于 2 对应的请求滞后返回了，因此最终展示了 `id` 为 2 所对应的 todo。

这个问题有很多解决方案：

- 借助闭包来解决：增加一个 `flag` 变量用来控制，当组件被卸载后，我们将 `flag` 置为 `false`，这样即使数据请求回来，也不会改写状态。


- 借助 Suspense 来解决：React Suspense 天然可以解决 Race Condition，这来源于两部分原因：1. 当异步请求发生时 UI 会立即渲染 fallback 状态；2. 数据请求与组件渲染逻辑分离。
- 借助 AbortController 来解决：`AbortController` 允许你主动取消正在进行中的异步操作，如 `fetch` 请求，可以用来避免不必要的资源消耗以及解决 Race Condition 问题。
- 借助一些开源库来解决：例如 TanStack Query / SWR 等等。


### 11. 怎么理解 React 并发更新特性？

> 参考 [探索 React 18 的并发渲染机制](https://juejin.cn/book/7311970169411567626/section/7313493075186647067#heading-0) 一节

并发更新是 React18 最主要的特性，同时由于并发机制的特性给社区带来了新的活力，当然也产生了一些新的问题，例如 React Tearing。

**为什么我们需要并发更新？**

我们看的电影和动画是由许多静态图像（帧）快速播放组成的，人眼的反应速度有限，当这些帧足够快地切换时，我们看到的就是流畅的动画。对于人眼来说，大约 16-24 帧/秒就足以形成连续动画的感觉，但更高的帧率会提供更流畅、自然的效果。

而常见的显示器刷新率有 60Hz、120Hz、144Hz 等（Hz 代表每秒更新画面的次数）。60Hz 的显示器意味着每秒钟屏幕刷新 60 次，即每次刷新间隔大约 16.7 毫秒。浏览器会自动适配这个频率，这时对应我们前端页面就是每 16.7ms 需要渲染一次。

但是我们知道，UI 渲染和 JS 执行都是运行在主线程上，也就是说当执行 JS 的时候就没有办法进行 UI 渲染，从而带来页面卡顿的感觉。并且正常 React 组件的渲染过程是连续的、不可被中断的，自然当 React 渲染时间过长时就会占用主线程阻止 UI 渲染从而带来卡顿的现象。

因此我们需要并发更新，也就是把连续的、不可中断的执行过程变成一小块、一小块的切片去执行，那在执行空隙期间自然有机会得到渲染。

<p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/738d54a767b04793a861f3d31e8420df~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1326&h=856&s=108859&e=png&b=ffffff" alt="image.png" width="70%" /></p>

同时在渲染的间隙我们也有机会去判断渲染优先级，从而优先执行高优先级的任务。

**并发更新是什么？**

React 并发更新 = Lane 模型 + 时间切片

- Lane 模型指的是会给每次渲染分配一个优先级，React 会根据这些不同的优先级来决定哪些更新应该优先处理，哪些可以稍后处理。
- 时间切片就是将整个连续不可中断的渲染过程变成可以中断的、离散的渲染。这样在间隙中可以判断是否有高优先级的任务，优先处理。以及渲染 UI 界面。

在背后 React 实现了 [Scheduler](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Freact%2Ftree%2Fmain%2Fpackages%2Fscheduler) 这个包来辅助完成整个过程。这个过程使用宏任务（React 会根据是否支持依次选择 `setImmediate` -> `MessageChannel` -> `setTimeout`），因为每执行一个宏任务，浏览器都会有机会得到渲染，如果微任务的话就需要等到清空微任务队列的全部任务。当 Scheduler 发现任务执行超过默认 5ms，就会让出主线程给 UI 渲染或者响应用户操作，从而完成了时间切片的能力。




### 12. 在并发更新的过程中怎么保证在组件间状态的一致性？

> 参考 [React 18 的并发挑战：如何解决状态 Tearing 问题？](https://juejin.cn/book/7311970169411567626/section/7312839604753661978) 一节

React18 增加了并发更新机制，`本质上是时间切片，并且高优先级会打断低优先级的任务`。在渲染的过程中，由于整个连续不断的渲染过程拆分成了一个个分片的渲染片段，因此在渲染的间隙时就有机会去响应用户的操作：

<p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb08952f26d349d1bf49af145beeaa18~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1324&h=1112&s=64798&e=png&b=ffffff" alt="image.png" width="90%" /></p>

因此当用户此时触发了更新状态的操作就会导致 Store 的状态被更新，在后续的渲染组件使用到的状态和已经渲染的状态不一致：

<p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d42c63f26bec44c4b8eba204a5e67d3f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2392&h=786&s=113353&e=png&b=ffffff" alt="image.png" width="100%" /></p>

这就是 React Tearing 问题，React 为生态提供了 `useSyncExternalStore` 来解决这个问题，核心原理就是将这次的并发更新变为同步更新（也就是不可中断） 。整个并发更新过程变回同步不可被中断了，自然也就不会有这个问题了。


### 13. Suspense 有哪些使用场景，使用 Suspense 的好处有哪些？

**使用场景有：**

- Suspense + lazy
- Suspense + 异步数据加载
- Suspense + use
- Suspense + useTransition
- Suspense + streaming

**好处有：**

-   **更优雅的写法**。使用 Suspense 可以避免写出下面这种代码：

```tsx
function App() {
  // 其它逻辑

  if (loading) {
    return <Loading />
  }
  return xxx;
}
```

-   解决 Race Condition 问题：React Suspense 天然可以解决 Race Condition，这来源于两部分原因：1. 当异步请求发生时 UI 会立即渲染 fallback 状态；2. 数据请求与组件渲染逻辑分离。
-   更好的性能：通常我们会将异步请求写在 `useEffect` 中，这需要等待渲染结束后才会发出请求，而使用 Suspense 可以把这部分前置到渲染时。
-   更好的用户体验：借助 `useTransition` 和 `Suspense` 可以降低此次的更新优先级以及延迟渲染，这样可以避免卡顿以及带来更好的用户体验。
-   流式渲染：`Suspense` 允许推迟某些内容的渲染，直到数据加载完毕。这样使得页面加载更快，无需等到数据准备好即可开始渲染和 hydration，降低 TTFB、FCP、TTI 等性能指标，从而用户可以更早地看到内容和进行交互。


### 14. 有没有用过原子化概念的状态管理库，比如 Jotai？怎么理解原子化的概念？

> 参考 [初识 Jotai：一个高性能原子化状态管理库](https://juejin.cn/book/7311970169411567626/section/7312837845533032485#heading-0) 一节

一个前端应用通常由多个组件组合而成，而组件之间自然就有了共享状态的需求，状态管理库就应运而生了，而这时候就诞生了两个派别 —— 以 Redux 为首的单一状态树与 Jotai 为首的原子化状态管理派别。`原子化`就是指整个应用的外部状态被拆分为了一个个分片的状态片段，每个状态片段保存在各自的 atom 中，各自的 atom 组合交错共同组成了整个应用的状态：

<p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6dba3e85b2b4fe4940a10e62113755a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2052&h=1022&s=166523&e=png&b=ffffff" alt="image.png" width="100%" /></p>

而 Jotai 帮助我们维护各个原子状态以及原子之间的依赖交错关系，并通过原子之间的相互依赖关系阻止应用 re-render，提高性能。例如当我们更新箭头指向的 atom 状态时：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/551cfc96a6e44af5bf61c6fcbb454048~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=980&h=806&s=79538&e=png&b=ffffff)

则最终触发组件 re-render 情况如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0b7ce1752d046d89b86b5f1a48bfd92~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1168&h=958&s=144531&e=png&b=ffffff)

即标蓝的 Component 最终被 re-render。




### 15. 你在项目中怎么处理异步数据的？为什么需要 TanStack Query/SWR 这类的库？


> 参考：[浅析 Race Condition（竞态）及其解决策略](https://juejin.cn/book/7311970169411567626/section/7318564163163258918)

对于应用来说实现一个简单的异步请求拿到数据后展示 UI 中非常容易，但在一个中大型复杂应用中我们需要考虑更多，比如：

- Race Condition 问题的解决：需要避免异步操作的结果顺序不确定性，导致最终的组件状态不符合预期的问题。
- 合理的封装：例如我们需要将一些逻辑合理的抽离成 Hooks，从而方便在不同的组件间进行逻辑复用。
- 预加载逻辑：比如我希望在用户进入某些页面前先去预加载这部分数据，这样当用户点进去看到的就是包含数据的页面，从而提高用户的体验。
- 错误重试能力：当请求出错了，应该帮助我们进行错误重试，并且我们可以动态的控制错误重试的次数和重试时间间隔。
- 请求去重：比如我在不同组件中同时发出了相同的请求，需要能够对这些重复的请求进行合并。
- 缓存机制：当我下一次需要这个数据时我可以不需要再重复发起请求。
- 缓存失效：既然有了缓存，就必须有缓存失效，避免内存泄漏。
- 乐观更新：例如我们希望在异步请求还没返回时先去更新某些状态，例如点赞，通常我们会先向用户展示点赞成功的动画。
- 支持 React 新特性：你可能会说这些功能我都能实现，但是如果有一天你离开了公司，那别人可能没有能力再去维护这些逻辑，这意味着当 React 更新了版本，或者底层依赖的其它库更新了，那某一天项目希望更新版本，是否会出现不兼容的情况导致 React 或者底层依赖库被迫无法升级的情况。
- ...



实现这些逻辑非常复杂，同时容易出问题，我们也很难保证能够一直有精力来维护，因此最好的选择是利用开源库而不是我们自己来实现。







