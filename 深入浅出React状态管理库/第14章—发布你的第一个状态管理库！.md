开发状态管理库的最后一步自然就是将其发布到 NPM 上以供别人下载和使用。在前面几节中，我们从 0～1 实现了 Zustand，在本节我们会完成相关的配置，并将该包发布于 NPM 上。


## 项目配置

### package.json 配置

在 [“前置知识：构建知识体系的基石”](https://juejin.cn/book/7311970169411567626/section/7319835446161178636) 这一节中，我们详细介绍了 `package.json` 中各个字段的含义。在发布之前，我们需要先完善一下 Zustand 包下 `package.json` 文件的相关配置：


```js
{
  "name": "custom-zustand",
  "version": "2.0.2",
  "description": "A custom implementation of Zustand",
  "author": "q-u-n",
  "type": "module",
  "main": "./dist/index.cjs",
  "module": "./dist/index.mjs",
  "types": "./dist/index.d.ts",
  "scripts": {
    "test": "jest --passWithNoTests --config jest.config.ts",
    "build": "pnpm run -w build:zustand",
    "prepublishOnly": "pnpm run build",
    "typecheck": "tsc"
  },
  "exports": {
    ".": {
      "import": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.mjs"
      },
      "require": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.cjs"
      }
    }
  },
  "keywords": [
    "react",
    "state",
    "manager",
    "management",
    "zustand"
  ],
  "files": [
    "dist"
  ],
  "sideEffects": false,
  "license": "MIT",
  "engines": {
    "node": ">=12.7.0"
  },
  "contributors": [],
  "bugs": {
    "url": "https://github.com/q-u-n/state-management-collection/issues"
  },
  "homepage": "https://github.com/q-u-n/state-management-collection",
  "dependencies": {
    "use-sync-external-store": "^1.2.0"
  },
  "devDependencies": {
    "@types/use-sync-external-store": "^0.0.6",
    "zustand": "^4.5.0"
  },
  "peerDependencies": {
    "react": ">=17.0.0"
  }
}
```

这里就不再赘述各项配置的作用了，如果对哪个具体配置不太熟悉的同学可以对应查阅 [“前置知识：构建知识体系的基石”](https://juejin.cn/book/7311970169411567626/section/7319835446161178636) 这一章节。





### LICENSE 文件

LICENSE 代表开源协议文件，用来告诉别人可以做什么或者不能做什么与你源代码相关的事情。如果没有配置该文件，那么默认的版权法将适用，意味着其他人无权复制、分发或创建基于你作品的派生作品。

因为我们是开源的，所以我们需要配置该文件，通常开源库所使用的都是 `MIT` 许可证。`MIT` 是一种开放源代码许可证，它允许广泛地自由使用、修改和再分发软件，但作者不会对软件的性能、适用性或任何潜在的缺陷提供任何形式的保证或担保，如果软件出现问题或导致损失，作者或分发者不承担任何责任。

GitHub 提供了一个网站 [choosealicense.com](https://choosealicense.com/) ，可以根据需要选择合适的许可证，并生成相应的许可证文本。

如果你也同样采用 `MIT` 许可证，可以复制下面文字到你项目中的 LICENSE 文件下。


```js
MIT License

Copyright (c) [year] [fullname]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

需要根据你的实际情况填充这里的 `year` 和 `fullname` 值，含义是：

- `year`：代表软件首次发布或者许可证被应用到软件上的那一年份。
- `fullname`：代表你的全名或你的组织/公司的名称。




## NPM 发布

我们先看一下正常发布到 NPM 的流程是怎么样的。没有 NPM 帐号的同学需要先[注册](https://www.npmjs.com/signup)一下 NPM 帐号，并在本地运行 `npm login` 进行登录。


1. **更新版本号**，即 `package.json` 中 `"version"` 字段，在每次发包时需要确认一下这个字段，增加一下版本号，NPM 不允许发布相同版本的包，避免在项目中所使用的依赖意外更改而收到影响，从而保证依赖的稳定性。
2. **打包 Zustand 代码**，因为最终其他包引入的是打包后的代码，也就是 `dist` 目录下的代码，因此我们需要在发布前确保该目录下的文件是最新打包的代码：



```js
pnpm run build:Zustand
```
3. **打标签**：使用 `git tag <tagname>` 添加新版本标签，用于标记对应发布版本的代码的状态，这样可以方便开发者追踪特定版本的代码，例如：


```js
git tag v1.0.0
```

我们可以在  GitHub 上查看对应的 Tag，如下：

<p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c42ba1725bb451cb8858cc642084610~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=998&h=1532&s=159306&e=png&b=ffffff" alt="image.png" width="50%" /></p>



4. **发布**：运行 `npm publish` 发布你的包。
5. **记录 changelogs**：当然最好我们也需要记录一下当前版本的详细信息，例如包含了哪些新的功能、修复了哪些错误、改进了哪些性能，等等。这样用户和项目的贡献者就能够清晰地了解到各个版本做了哪些更改。


试想一下：如果手动发布 NPM 包，我们会面临什么问题？

- 你需要手动管理包的版本，通常我们需要确保包版本是连续的。
- 在发布前需要手动打包一下，确保上传的文件是最新的。
- 同时也需要手动打 Tag，并上传到 GitHub 仓库中。
- 需要手动维护 changelogs。
- 在 Monorepo 项目中可能会同时包含多个需要发布和维护的包，可能存在同时需要发布多个包的情况，例如在多个包依赖的公共部分发生变化时，意味着这些关联的包都需要发布，手动管理极为繁琐以及容易遗漏。


可以看到，如果手动管理包的发布需要做很多事情，并且容易遗漏，如果有一个工具可以帮助我们自动完成所有工作就好了！

版本管理和自动化发布工具其实有很多，例如：

- Changesets：https://github.com/changesets/changesets
- Release-it：https://github.com/release-it/release-it
- Semantic Release：https://github.com/semantic-release/semantic-release
- 等等

由于我们这里使用 Monorepo 来管理项目，而 Changesets 特别适合于 Monorepo 场景，因此采用 Changesets 来作为版本管理工具。


## Changesets

Changesets 是用于管理版本和 changelogs 的工具，特别适合于 Monorepo 项目使用。很多知名的库，例如 pnpm、XState、MobX [等等](https://github.com/changesets/changesets?tab=readme-ov-file#cool-projects-already-using-changesets-for-versioning-and-changelogs)都在使用 Changesets。

接下来让我们看一下`如何用 Changesets 来管理我们的项目`。

### 使用


**安装依赖：**

```
pnpm add @changesets/cli @changesets/changelog-github -wD
```

**初始化 Changesets：**

```js
pnpm changeset init
```

执行完后会在根目录下生成 `.changeset` 目录，其中的 `config.json` 是 `changeset` 的[配置](https://github.com/changesets/changesets/blob/main/docs/config-file-options.md)文件，我们来改一下这个文件：


```js
{
  "changelog": [
    "@changesets/changelog-github",
    { "repo": "q-u-n/state-management-collection" }
  ],
  "access": "public",
  "baseBranch": "main",
  "tag": true
}
```

其中：

- `changelog`：用于设置如何生成包的 changelogs，如果指定为 `false` 代表不生成任何 changelogs，指定一个路径则代表 Changesets 将会从中获取 changelogs 生成的函数。我们这里指定为 `@changesets/changelog-github`，它需要 GitHub 身份验证，并添加向贡献的人感谢内容以及对应的 PR 链接，例如：


<p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdc3e7b7af6a4482a961b3bcbf7e81dd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1750&h=566&s=117446&e=png&b=ffffff" alt="image.png" width="70%" /></p>

- `access`：默认值为 `restricted`，代表该包为私有的，适用于私有项目或企业内部使用的包。这里我们是开源的项目，指定为 `public`。
- `baseBranch`：指定的主分支，默认为 `master`，这里我们改为 `main` 分支。
- `tag`：设置为 `true`，在通过 Changesets 工具发包时会帮我们自动打 Tag。


**生成 changeset 文件**



我们在 package.json 增加一些命令，用来执行本地安装的 `changeset cli` 命令：

```js
"changeset": "changeset",
"version": "changeset version",
"release": "changeset publish",
```

然后运行 `pnpm run changeset`，接下来会依次要求你填写一些信息：



<p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0abaceb0cbaa46f09d6525a5efbb069a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1202&h=548&s=140021&e=png&b=1f1f1f" alt="image.png" width="80%" /></p>

这里需要注意一下 major、minor 和 patch 的区别，一个版本号格式如下：`major.minor.patch`，其中：

- major（主版本号）：做了向后不兼容的 API 更改时，需要增加主版本号。
- minor（次版本号）：添加了新的功能并且向后兼容，需要增加次版本号。
- patch（修订号）：做了向后兼容的问题修正时，例如 bug 修复或者小的改进，需要增加修订号。

然后在 `.changeset` 目录下会生成一个文件名随机的文件：


<p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/205dca3fa1614502b301487a1629ccaa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=570&h=416&s=30581&e=png&b=1e1e1e" alt="image.png" width="50%" /></p>

在该文件中记录了变更的包以及变更的信息，changeset 文件可以随着开发者迭代不断地积累，例如 pnpm 就积累了很多文件：


<p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da98e4768f5f4db9b112838c15791457~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=632&h=1460&s=139003&e=png&b=ffffff" alt="image.png" width="40%" /></p>

当执行 `changeset version` 时会消耗这些文件，并生成对应项目下的 CHANGELOG.md 文件，以及更改项目 `"version"` 版本。让我们再执行一遍
 `pnpm run changeset` 命令：
 
 
<p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a03c936ba46409dbc28c6220bdaaeb9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=710&h=136&s=27366&e=png&b=262627" alt="image.png" width="70%" /></p>

**更新版本号 && 生成 changelogs**

可以看到此时已经积累了两个 changeset 文件，现在让我们执行命令：


```js
pnpm run version
```


<p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfa89cc5f0914b1891bd51a941b35e19~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=212&s=46652&e=png&b=262627" alt="image.png" width="70%" /></p>


<p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d69814900854ba88d8f0a9b17763718~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=478&h=494&s=44969&e=png&b=1f1f1f" alt="image.png" width="50%" /></p>


可以看到已经删除了这两个文件，并且在 CHANGELOG.md 文件中包含了这两次提交的信息。






**发包 && 打 Tag**

`changesets publish` 将发布那些在 `changesets version` 步骤中版本号被更新的包到 NPM，本质上还是在每个包下执行 `npm publish` 命令。


通常在发布包之前我们需要重新运行打包命令，以确保发布上去的是最新的代码。而在执行 npm publish 前 [npm 会执行一系列生命周期脚本](https://docs.npmjs.com/cli/v7/using-npm/scripts)，因此我们可以在 `prepublishOnly` 阶段跑打包命令，在 zustand 包下 `package.json` 文件中增加命令：


```js
"build": "pnpm run -w build:zustand",
"prepublishOnly": "pnpm run build",
```


然后将 tag 推送到 GitHub 仓库。使用 `git push origin <tagname>` 推送特定标签到远程仓库，或者使用 `git push origin --tags` 推送所有标签。



<p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a554c3ca79a8443598b8f405292538a2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=742&h=602&s=66467&e=png&b=ffffff" alt="image.png" width="50%" /></p>


现在可以看到 Changesets 帮我们打好的标签了。我们画个图来表示一下这个过程：



<p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5238a20a49904f379f8c340d11e22a3a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1106&h=686&s=63287&e=png&b=ffffff" alt="image.png" width="70%" /></p>


Changesets 将开发者分为 contributor 和 maintainer，对于 contributor 只需要关心生成 changeset，而 maintainer 需要管理接下来的版本更新、Tag 生成、包发布等等事情。


### GitHub Action 与版本管理

可以看到，我们已经由手动管理切换到了利用 Changesets 来帮助我们管理，但是对于 maintainers 来说仍然有一点繁琐。那这些开源项目都是怎么做的呢？

我们以 [MobX](https://github.com/mobxjs/mobx/releases) 为例，可以在它的 Releases 页面清楚地看到每个版本做了哪些改动，以及改动的详细信息。



![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03934a05a6a741358414dd78c252df2a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2878&h=1430&s=301447&e=png&b=ffffff)

因此，标准的做法是将这个过程集成到 GitHub Actions 中，整个流程大致是这样的：

1. 添加 changeset 文件，首先项目的开发者在开发完一个功能后在本地运行 `pnpm run changeset` 生成 changeset 文件，包含更改的描述和决定版本号如何变化信息。
2. 推送 changeset 文件，将这个 changeset 文件提交到你的代码仓库中并推送到 GitHub 仓库中。
3. GitHub Actions 会触发并运行定义好的 `changesets/action`。这个 Action 会根据这些未被处理的 changeset 文件自动创建一个包含这些变更信息的 Pull Request，[例如](https://github.com/mobxjs/mobx/pull/3813)：


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75e52e414fd144f6a7e45c2039156233~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2860&h=1614&s=479237&e=png&b=ffffff)


4. PR 被合并到主分支后，`changesets/action` 会触发最终的发布过程，例如自动将新的包发布到 NPM、更新 `package.json` 中的版本号、生成 `CHANGELOG.md` 日志、打 Tag 等。


好！让我们一步一步在我们的仓库中实现这个过程。


1. 首先既然整个过程是集成在 GitHub Action 中的，因此首先我们需要在项目中配置 [release.yml](https://github.com/q-u-n/state-management-collection/blob/main/.github/workflows/release.yml) 文件：

```yml
name: release

on:
  push:
    branches: [main]

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: pnpm
      - name: Install dependencies
        run: pnpm install --frozen-lockfile --prefer-offline
      - name: Create Release Pull Request or Publish to npm
        uses: changesets/action@master
        with:
          publish: pnpm run release
          commit: Version release
          title: Next release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}

```

其中上面部分和 [“项目搭建：从配置到 CI 的全方位指南”](https://juejin.cn/book/7311970169411567626/section/7313461952565985331) 一节中提到的配置一致，重点介绍一下后面这部分的作用：


```yml
- name: Create Release Pull Request or Publish to npm # 名称
  uses: changesets/action@master # 使用 changesets/action 管理项目版本和发布
  with: # 定义了步骤的输入参数
    publish: pnpm run release # 发布时执行的命令
    commit: Version release # 自动创建的版本提交信息
    title: Next release # 自动创建的 PR 的标题
  env: # 环境变量
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # GitHub自动为每个仓库生成的Token
    NPM_TOKEN: ${{ secrets.NPM_TOKEN }} # 需要我们手动在仓库内配置
```



2. 生成 NPM Access Token 并配置到 GitHub 上。

上面提到，环境变量包含了两个，其中 `secrets.GITHUB_TOKEN` 是 GitHub 自动生成的，不需要我们手动配置。而 `secrets.NPM_TOKEN` 的作用是授权发布包到 NPM 上，因此需要我们在 NPM 上生成这个 Token，并在的 GitHub 仓库的 Secrets 中添加它。

访问 [NPM](https://www.npmjs.com/) 官网，点击右上角头像下拉框的 Access Tokens：

<p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9267edeb5f1b43c3a85a2001b6ebe4f3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=536&h=1028&s=64335&e=png&b=fdfdfd" alt="image.png" width="40%" /></p>


点击 Generate New Token -> Classic Token，然后选择 publish：


<p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/405603b67096409dbcc835ae7829714c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1534&h=1458&s=213323&e=png&b=f9f9f9" alt="image.png" width="70%" /></p>

点击 Generate Token 按钮就生成好了。接下来复制该 Token，进入我们项目目录下，点击 Settings -> Secrets and variables -> Actions -> New repository secret：



![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a25c7652796406bb3b72e4d5b44c0fd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2814&h=1668&s=455109&e=png&b=ffffff)

名字填 `NPM_TOKEN`，Secret 就是你刚才从 NPM 中复制的那个 Token。
然后你需要确保 Actions -> General 页面，拉到底下面这个配置和我是一样的：



<p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fde357d8ebbd47c8b92c55009159a308~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1576&h=624&s=160555&e=png&b=ffffff" alt="image.png" width="70%" /></p>





3. 将刚才配置的 release.yml 文件推送到 GitHub 仓库中，这时候点击上方进入 Actions 页面，如果发现已经可以正常跑通了，就说明你前面的配置没有问题。



![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea66c9e7955d47d5a53384d365e9036b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2878&h=1592&s=409514&e=png&b=ffffff)

如果没跑通需要检查上面的流程，重新配置并重新运行 workflow。


4. 在本地生成一个 changeset 文件，运行 `pnpm run changeset` 命令，这里其实就和大家日常开发一样了，生成好 changeset 文件后推送到远程仓库即可。这时候 GitHub Actions 会帮助你创建一个 PR 并记录这些变更信息：https://github.com/q-u-n/state-management-collection/pull/2 。


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46f2d735924443f38c167f2452378f09~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2878&h=1614&s=437712&e=png&b=ffffff)

5. 最后将这个 PR 合入到主分支，GitHub Actions 会自动帮助我们发布该版本、新 `package.json` 中的版本号、生成 `CHANGELOG.md` 日志：


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0911ac1284a84487ba44cbc0a2654e53~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2878&h=1374&s=253774&e=png&b=ffffff)


至此，我们已经跑通了整个流程。



## 总结

在本节中，我们完成了 Zustand 发布前的相关配置，并讲解了如何将自己的包发布到 NPM 上，以及手动发布的缺点。最后还介绍了利用 Changesets 用来管理 Monorepo 包的发布过程、如何解决这些痛点，以及如何将整个流程集成到 GitHub Actions 中。


至此，我们就结束了 Zustand 相关的全部内容。