从本节开始我们来讲一下 GraphQL，在 GraphQL 课程的设计中，整个 GraphQL 章节会被分成三个部分：

- **GraphQL 快速入门**：在这部分我们会介绍 GraphQL 的基本概念、GraphQL 生态（GraphQL.js、Apollo Client、Apollo Server、NestJS）库的用法。
- **手写 Apollo Client**：在 TanStack Query 章节中其实我们已经实现了一些非常有趣的高级能力，比如错误重试、缓存回收、预加载等等，因此在 Apollo Client 中我们就不再重复实现这些能力了。而 Subscription 是 GraphQL 中的一个重要且非常有趣的能力，背后借助 WebSocket，因此在设计中我们会重点实现框架搭建以及 Subscription 能力。
- **项目实战**：我们会完成一个 GraphQL 相关的实战项目。



# GraphQL

**什么是 GraphQL？**


<p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/993dcae3984e422d8480f850f185ce9f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1182&h=336&s=33774&e=png&b=fefefe" alt="image.png" width="80%" /></p>

当我们在谈论 GraphQL 时，我们称它其实是一种数据查询和操作的**语言**。


在日常开发中，通常我们会使用 REST API 来完成数据的请求，而这些数据会包含在不同的接口中，往往我们需要请求多个接口才能够拿到我们想要的数据。

例如当我们在设计购物网站的个人界面时，在个人页中通常会展示个人的基本信息、订单记录、收货地址等等，而这些信息通常会在不同的接口中去获取：



<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1687c417fc14e95b4e29d241e4ea2cc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1042&h=334&s=30797&e=png&b=fefefe" alt="image.png"  width="80%"/></p>

而同时，请求到的数据中也包含了大量无用的数据，也就是说我们在前端无法控制服务端给我们什么。而 GraphQL 帮助我们解决了这个问题，GraphQL 只暴露了一个接口，通过这个接口，我们就可以拿到前端想要的任何数据：



<p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af80373446004b35a6c413176169f864~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1066&h=350&s=23994&e=png&b=ffffff" alt="image.png" width="80%" /></p>

也就是说从以前的服务端决定给我们什么数据变为由客户端决定，并且只需要一个接口就能够完成一切事情！这也是 GraphQL 被发明出来的初衷，在 Facebook 中，随着移动应用的复杂性增加，传统的 REST API 开始显得不够高效和灵活，为了解决这些问题，Facebook 开发了 GraphQL，并在 2015 年进行了开源。


再举一个例子：

比如书和作者是对应关系，每本书会有很多作者，每个作者会对应写一些书，而书又包含了其他信息比如书名、出版年份等等，作者也包含了作者名、国家。在 REST API 中我们通常会直接把这些信息返回给前端，无论前端是否使用，而在 GraphQL 中我们可以根据需要去按需获取。

比如我现在想要获取全部书的书名：


<p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f29b8aa60b244688bdd9c335e2f30b2b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1800&h=1154&s=100683&e=png&b=ffffff" alt="image.png" width="100%" /></p>

可以看到在左侧只取了 `title`，而返回结果数组中也只包含了 `title`，那如果我也想知道书的出版年份呢：


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/589b3ebad33740d0b404bcb79ab7548b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1802&h=1134&s=118108&e=png&b=ffffff)

我们只需要把 `year` 也加进来就可以了，如果我们想知道书对应的作者信息呢：


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/deed29ab58df4261a1849a7382457cee~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1912&h=1314&s=156698&e=png&b=f4f6f8)



通常如果我们需要开发一个全栈项目时我们在前端通常会使用 `@apollo/client` 这个包，在服务端会使用 `@apollo/server`（或者 NestJS）。但是如果你看 Apollo [官网](https://www.apollographql.com/docs/react/get-started)你会发现，无论安装 `@apollo/client` 还是 `@apollo/server` 都需要安装 `graphql`，因此我们需要首先理清一下这几个包之间的关系。



<p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a228bae620e240f396ca9e78a75a09c1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1204&h=406&s=62025&e=png&b=ffffff" alt="image.png" width="90%" /></p>

- `graphql`：实现了核心 GraphQL 能力，比如 GraphQL 查询语句的解析和执行，是任何上层框架的基础。
- `@apollo/client`：运行在客户端的**状态管理库**，允许你借助 GraphQL 来查询服务端的数据，同时类似 Tanstack Query，给我们提供了很多很棒的能力！比如订阅、缓存、预请求等等......
- `@apollo/server`：构建和运行 GraphQL 服务器，处理客户端的 GraphQL 请求，然后交给 `graphql` 去解析和执行，然后返回给客户端。



# Server（@apollo/server）

我们先来快速入门一下 `@apollo/client`，代码见：https://github.com/L-Qun/state-management-collection/tree/main/examples/graphql/apollo-server

首先我们需要先安装 `@apollo/server`、`graphql`：


```js
npm install @apollo/server graphql
```

然后我们需要定义一下 GraphQL Schema，GraphQL Schema 是类型系统，用来描述服务端数据的形状和方式，以及客户端可以如何查询这些数据。


```js
const typeDefs = `
  type Book {
    title: String
    authors: [Author]
    year: Int
  }

  type Author {
    name: String
    books: [Book]
    nationality: String
  }

  type Query {
    books: [Book]
    authors: [Author]
  }
`
```

当然 Apollo Server 也需要知道应该给客户端返回哪些数据，对应 Resolver：


```js
const authors = []
const books = []

const book1 = { title: 'book1', authors: [], year: 2021 }
const book2 = { title: 'book2', authors: [], year: 2022 }
const book3 = { title: 'book3', authors: [], year: 2021 }

books.push(book1, book2, book3)

const author1 = {
  name: 'author1',
  books: [book1, book2],
  nationality: 'American',
}
const author2 = { name: 'author2', books: [book2], nationality: 'British' }
const author3 = { name: 'author3', books: [book3], nationality: 'Canadian' }

authors.push(author1, author2, author3)

book1.authors.push(author1, author3)
book2.authors.push(author1, author2)
book3.authors.push(author3)

const resolvers = {
  Query: {
    books: () => books,
    authors: () => authors,
  },
}
```

这里为了方便演示写死了数据，最后我们创建 Server 并启动：


```js
const server = new ApolloServer({
  typeDefs,
  resolvers,
})

const { url } = await startStandaloneServer(server, {
  listen: { port: 4000 },
})

console.log(`🚀  Server ready at: ${url}`)
```

`package.json` 加一个 script：


```js
"scripts": {
  "start": "node src/index.js"
},
```

启动：`npm run start`，此时服务器就已经跑起来了。

当我们打开 `localhost:4000` 可以看到 Apollo Sandbox：


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9d42c841f4e44b2aa3970f48970bb60~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2880&h=1624&s=188778&e=png&b=ffffff)

可以在 Apollo Sandbox 中方便的完成 GraphQL 查询，比如当我想拿到 books 对应的名字和年份


```js
query Books {
  books {
    title
    year
  }
}
```


![20240804231838_rec_.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f663456c847472a92b20d1346c0abfb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1922&h=1078&s=394763&e=gif&f=116&b=f1f6f8)

如果我也想拿到书对应的作者信息：


```js
query Books {
  books {
    title
    year
    authors {
      name
    }
  }
}
```

![20240804232015_rec_.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ab8365f4b2d4632945e1b69ecade098~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1920&h=1080&s=280827&e=gif&f=54&b=f0f5f7)

可以看到返回结果中只包含了我们想要的数据，不包含任何其它的冗余的数据。

# Client（@apollo/client）

有了服务端部分，接下来我们需要完成客户端部分，借助 `@apollo/client` 完成数据的请求并展示到前端。代码见：https://github.com/L-Qun/state-management-collection/tree/main/examples/graphql/apollo-client

首先可以基于 `create-react-app` 快速生成 React 应用的基础结构：



```js
npx create-react-app my-app
```

然后我们需要安装相关的依赖：


```js
npm install @apollo/client graphql
```

初始化 Apollo Client 实例：


```js
import { ApolloClient, InMemoryCache, ApolloProvider } from '@apollo/client'

const client = new ApolloClient({
  uri: 'http://localhost:4000',
  cache: new InMemoryCache(),
})
```

其中：

- uri 代表我们要请求的地址，在这里也就是我们在服务端刚启动的 `localhost:4000`。
- cache 用来缓存 GraphQL 查询结果。



```js
import React from 'react'
import ReactDOM from 'react-dom/client'
import { ApolloClient, InMemoryCache, ApolloProvider } from '@apollo/client'
import App from './App'

const client = new ApolloClient({
  uri: 'http://localhost:4000',
  cache: new InMemoryCache(),
})

const root = ReactDOM.createRoot(document.getElementById('root'))
root.render(
  <React.StrictMode>
    <ApolloProvider client={client}>
      <App />
    </ApolloProvider>
  </React.StrictMode>,
)
```

使用 `useQuery` 查询数据，其中 `GET_BOOKS` 就是 GraphQL 查询语句：


```js
import { useQuery, gql } from '@apollo/client'

const GET_BOOKS = gql`
  query Books {
    books {
      title
      year
      authors {
        name
      }
    }
  }
`

export default function App() {
  const { data, loading } = useQuery(GET_BOOKS)

  if (loading) return <div>loading...</div>

  return (
    <>
      {data.books.map(({ title, year, authors }) => (
        <>
          <p>
            {title}-{year}
          </p>
          <ul>
            {authors.map((author) => (
              <li>{author.name}</li>
            ))}
          </ul>
        </>
      ))}
    </>
  )
}
```

最后我们运行 `npm run start` 启动项目：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40b8211f0552488a9aa7b1e43fe5828e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=578&h=720&s=45807&e=png&b=ffffff" alt="image.png" width="50%" /></p>

可以看到正确的从 Server 拿到了数据并展示到了前端。
 
# Mutation（变更）

前面我们介绍了查询，那你可能会问，如果我想更新某个数据应该怎么做呢？比如我想插入一本书，我们就可以借助 Mutation，Mutation 用于修改数据。它可以改变后端的状态，如添加、更新或删除数据。类似于 REST API 中的 POST、PUT、DELETE 请求。当然无论 Query 还是 Mutation 和 HTTP 方法一样都是语义上的，具体行为取决于我们的代码。

接下来我们来编写插入一本书的代码：


```js
const typeDefs = `
  type Book {
    title: String
    authors: [Author]
    year: Int
  }

  type Author {
    name: String
    books: [Book]
    nationality: String
  }

  type Query {
    books: [Book]
    authors: [Author]
  }

+ type Mutation {
+   addBook(title: String!, year: Int!, authorNames: [String]!): Book
+ }
`

const resolvers = {
  Query: {
    books: () => books,
    authors: () => authors,
  },
+ Mutation: {
+   addBook: (_, { title, year, authorNames }) => {
+     const newBook = {
+       title,
+       year,
+       authors: authors.filter((author) => authorNames.includes(author.name)),
+     }
+     books.push(newBook)
+     return newBook
+   },
+ },
}
```

其中 `!` 代表该参数必传，然后我们可以在 Apollo Server 执行 Mutation 查询：



![20240811171935_rec_.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6347f76b85c04fde858725e2c4b29328~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1920&h=1080&s=508314&e=gif&f=221&b=f9f8fc)

然后我们测试一下：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86dc64b6bdd54d16a606af53443dbba8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2878&h=1616&s=276196&e=png&b=f4f6f8)

可以看到 book4 已经被成功添加进来了。

服务端已经定义好了，接下来我们可以改下前端的代码。首先定义一个新的 Mutation 查询，这里和上面在 Apollo Server 演示的一样：

```js
const ADD_BOOK_MUTATION = gql`
  mutation AddBook($title: String!, $year: Int!, $authorNames: [String]!) {
    addBook(title: $title, year: $year, authorNames: $authorNames) {
      title
    }
  }
`
```

对应的 `@apollo/client` 给我们提供了 `useMutation` 来更新数据：



```js
export default function App() {
  const { data, loading } = useQuery(GET_BOOKS)

  const [mutateFunction, { loading: mutationLoading }] = useMutation(
    ADD_BOOK_MUTATION,
    {
      refetchQueries: [GET_BOOKS],
    },
  )

  if (loading) return <div>loading...</div>

  return (
    <>
      {data.books.map(({ title, year, authors }) => (
        <>
          <p>
            {title}-{year}
          </p>
          <ul>
            {authors.map((author) => (
              <li>{author.name}</li>
            ))}
          </ul>
        </>
      ))}
      <button
        disabled={mutationLoading}
        onClick={() => {
          mutateFunction({
            variables: {
              title: 'book4',
              year: 2024,
              authorNames: ['author1', 'author2', 'author3'],
            },
          })
        }}
      >
        add a book
      </button>
    </>
  )
}
```

现在，在页面中新增了一个按钮，当我们点击按钮时对应执行 Mutation 查询，并将参数作为 `variables` 传进去，最后更新 UI。上面的 GraphQL 语法我们会在下一节进一步进行介绍。

<p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/967e39ab17194b08ae43753755e0dfea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=676&h=1264&s=38575&e=gif&f=17&b=fcfbfe" alt="20240811165500_rec_.gif"  width="50%"/></p>

# 总结

本章我们通过一个案例快速入门了 GraphQL，并介绍了一些核心概念。我们可以再梳理一下，GraphQL 是一门查询语言，我们作为前端想要使用 GraphQL 意味着需要后端的支持。那建立 GraphQL 系统前后端都需要做哪些基本的事情呢？

客户端：

- 定义 GraphQL 查询语句

比如我们前面在 GraphQL Sandbox 或者在前端编写的查询语句，例如：


```js
query Books {
  books {
    title
    year
    authors {
      name
    }
  }
}
```

服务端：

- 定义 Schema，描述了服务端可以提供什么数据以及客户端如何请求这些数据。比如：


```js
type Book {
  title: String
  authors: [Author]
  year: Int
}

type Author {
  name: String
  books: [Book]
  nationality: String
}

type Query {
  books: [Book]
  authors: [Author]
}
```


- 实现 Resolver，负责获取客户端请求的具体数据。比如：


```js
const resolvers = {
  Query: {
    books: () => books,
    authors: () => authors,
  },
}
```


整个流程：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e25583527d04c8ebbc72f7e04c02e9d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1242&h=462&s=36879&e=png&b=ffffff)


通过这些概念和案例我们了解了 GraphQL 的诸多优点：

- 精确获取数据：GraphQL 可以使我们精确选取我们需要的数据，从而避免了获取数据过多或过少的问题。
- 单一接口：REST 中需要多个 API 处理不同数据请求，GraphQL 只使用单一 API 就可以处理所有数据请求。
- 强大的开发工具：前面我们介绍了 Apollo Sandbox，通过这些工具我们可以直接看到后端给我们提供了哪些数据，也可以直接在图形界面上进行请求，几乎不需要什么 API 文档，避免我们和后端吵架（狗头）。
- 无需接口类型定义：可以借助 GraphQL-Codegen 工具自动根据后端的 Schema 为我们生成请求数据的类型定义，无需我们自己编写非常方便，这个我们在后续 GraphQL 最佳实践一节中会介绍到。


在接下来的章节中我们会进一步细致的讲解 GraphQL 的语法和各类技术。

那既然 GraphQL 那么好用，可以很方便的直接在一个请求中拿到所有前端想要的数据，那什么时候不适合用 GraphQL 呢？

- **团队经验**：如果你们团队不具备 GraphQL 的开发经验，那么则不适合使用 GraphQL，从本节中我们也可以看到 GraphQL 本身有较高的学习成本。
- **需求**：如果对接口聚合以及按需获取需求不那么强烈，比如本身应用较小，数据不太复杂，则使用 REST API 就能够满足绝大部分业务。
- **服务**：如果你的服务需要开放出去给其他业务使用（Open API），那么就可能要考虑是否满足使用方的习惯了，因为绝大多数客户端都是使用的 REST API。